/*
 * WarframeStat.us API
 *
 * Simple API for data from the game Warframe. [Parser Docs](https://wfcd.github.io/warframe-worldstate-parser/) [Items Types](https://github.com/WFCD/warframe-items/blob/master/index.d.ts) 
 *
 * The version of the OpenAPI document: 2.0.8
 * Contact: tobiah@protonmail.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_acolytes_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAcolytesByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_alerts_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAlertsByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_arbitration_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetArbitrationByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_archon_hunt_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetArchonHuntByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_baro_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBaroByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_cambion_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCambionByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_cetus_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCetusByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_conclave_challenges_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetConclaveChallengesByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_construction_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetConstructionByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dark_sectors_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDarkSectorsByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_deals_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDealsByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_deep_archimedea_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDeepArchimedeaByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_earth_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEarthByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_events_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventsByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_fissures_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFissuresByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_global_effects_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGlobalEffectsByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_invasions_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInvasionsByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_kuva_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetKuvaByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_news_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNewsByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_nightwave_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNightwaveByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_outposts_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOutpostsByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rivens_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRivensByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sales_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSalesByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simaris_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimarisByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sortie_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSortieByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_steel_path_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSteelPathByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_syndicates_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSyndicatesByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_timestamp_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimestampByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_vallis_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVallisByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_varzia_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVarziaByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_void_traders_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVoidTradersByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_worldstate_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorldstateByPlatformError {
    Status400(models::InlineObject),
    Status404(models::InlineObject1),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_rivens_by_platform`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchRivensByPlatformError {
    Status400(models::InlineObject),
    Status500(models::InlineObject),
    UnknownValue(serde_json::Value),
}


/// Data about current acolytes attacking the Sol System
pub async fn get_acolytes_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<Vec<models::PersistentEnemiesInner>, Error<GetAcolytesByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/persistentEnemies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PersistentEnemiesInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PersistentEnemiesInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAcolytesByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Description and rewards for Alerts
pub async fn get_alerts_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<Vec<models::AlertsInner>, Error<GetAlertsByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/alerts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AlertsInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AlertsInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAlertsByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Description of the currently active arbitration
pub async fn get_arbitration_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::Arbitration, Error<GetArbitrationByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/arbitration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Arbitration`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Arbitration`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetArbitrationByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Data about the missions for the current archon hunt
pub async fn get_archon_hunt_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::ArchonHunt, Error<GetArchonHuntByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/archonHunt", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ArchonHunt`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ArchonHunt`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetArchonHuntByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Information on the current Void Trader offerings, or when he will arrive.
pub async fn get_baro_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::VoidTrader, Error<GetBaroByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/voidTrader", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VoidTrader`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VoidTrader`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBaroByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Data on the Vome/Fass cycle for the Cambion Drift on Deimos
pub async fn get_cambion_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::CambionCycle, Error<GetCambionByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/cambionCycle", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CambionCycle`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CambionCycle`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCambionByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Data on the day/night cycle for Cetus on Earth
pub async fn get_cetus_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::CetusCycle, Error<GetCetusByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/cetusCycle", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CetusCycle`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CetusCycle`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCetusByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Data on each day and week's conclave challenges
pub async fn get_conclave_challenges_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<Vec<models::ConclaveChallengesInner>, Error<GetConclaveChallengesByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/conclaveChallenges", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ConclaveChallengesInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ConclaveChallengesInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetConclaveChallengesByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Construction percentages for showing how far constructed the enemy fleets are.
pub async fn get_construction_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::Construction, Error<GetConstructionByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/constructionProgress", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Construction`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Construction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetConstructionByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Dark Sector (Rail Wars) data and history. Digital Extremes has emptied several of these.
pub async fn get_dark_sectors_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<Vec<models::DarkSectorsInner>, Error<GetDarkSectorsByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/darkSectors", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::DarkSectorsInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::DarkSectorsInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDarkSectorsByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Darvo's Daily Deal details
pub async fn get_deals_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<Vec<models::DailyDealsInner>, Error<GetDealsByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/dailyDeals", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::DailyDealsInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::DailyDealsInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDealsByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Data on current Deep Archimedea missions, deviations, risk variables,  and personal modifiers may not be up to date and, in some cases, may be omitted from the world state.
pub async fn get_deep_archimedea_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::DeepArchimedea, Error<GetDeepArchimedeaByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/deepArchimedea", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeepArchimedea`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeepArchimedea`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDeepArchimedeaByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The current Earth day/night cycle progress.
pub async fn get_earth_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::EarthCycle, Error<GetEarthByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/earthCycle", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EarthCycle`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EarthCycle`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEarthByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Events, such as Fomorian Attacks are included here
pub async fn get_events_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<Vec<models::Event>, Error<GetEventsByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/events", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventsByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Information about current Void Fissure missions
pub async fn get_fissures_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<serde_json::Value, Error<GetFissuresByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/fissures", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFissuresByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Any current modifiers applied to all users, such as double drops.
pub async fn get_global_effects_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<Vec<models::GlobalUpgradesInner>, Error<GetGlobalEffectsByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/globalUpgrades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GlobalUpgradesInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GlobalUpgradesInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGlobalEffectsByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Data on invasion missions, such as estimated completion time, rewards, etc.
pub async fn get_invasions_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<Vec<models::Invasion>, Error<GetInvasionsByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/invasions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Invasion&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Invasion&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInvasionsByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Current Kuva Mission listing (provided by [semlar](https://10o.io/kuvalog)).
pub async fn get_kuva_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<Vec<models::Arbitration>, Error<GetKuvaByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/kuva", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Arbitration&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Arbitration&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetKuvaByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Translated News items from the worldstate
pub async fn get_news_by_platform(configuration: &configuration::Configuration, ) -> Result<Vec<models::NewsInner>, Error<GetNewsByPlatformError>> {

    let uri_str = format!("{}/pc/news", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::NewsInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::NewsInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNewsByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Current cycle and challenges of Nightwave, a battle-pass-esque rotation and challenge system
pub async fn get_nightwave_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::Nightwave, Error<GetNightwaveByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/nightwave", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Nightwave`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Nightwave`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNightwaveByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Status data for current Sentient Outpost, if any. Parsed source is combined data from DE\\'s worldstate and [semlar\\'s data](https://semlar.com/anomaly.json)
pub async fn get_outposts_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::SentientOutposts, Error<GetOutpostsByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/sentientOutposts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SentientOutposts`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SentientOutposts`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOutpostsByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Data about averages, deviations, medians, miniums, and maxes for all rivens for the provided platform
pub async fn get_rivens_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<std::collections::HashMap<String, models::Riven>, Error<GetRivensByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/rivens", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::Riven&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::Riven&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRivensByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Popular Deals, discounts, featured deals.
pub async fn get_sales_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::FlashSales, Error<GetSalesByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/flashSales", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FlashSales`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FlashSales`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSalesByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Status data for Simaris' Sanctuary
pub async fn get_simaris_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::Simaris, Error<GetSimarisByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/simaris", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Simaris`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Simaris`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimarisByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Data about the missions for the current sortie
pub async fn get_sortie_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::Sortie, Error<GetSortieByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/sortie", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sortie`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sortie`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSortieByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Data about the missions for the current sortie
pub async fn get_steel_path_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::SteelPath, Error<GetSteelPathByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/steelPath", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SteelPath`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SteelPath`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSteelPathByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cycling through different nodes each day, these are a general listing of the nodes that each syndicate will use for the day.
pub async fn get_syndicates_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<Vec<models::SyndicateMission>, Error<GetSyndicatesByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/syndicateMissions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SyndicateMission&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SyndicateMission&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSyndicatesByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The time that the worldstate was last generated
pub async fn get_timestamp_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<String, Error<GetTimestampByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/timestamp", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimestampByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The current cycle of the Orb Vallis warm/cold cycle
pub async fn get_vallis_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::VallisCycle, Error<GetVallisByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/vallisCycle", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VallisCycle`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VallisCycle`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVallisByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Information on the current Varzia offerings, or when she will arrive.
pub async fn get_varzia_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::VoidTrader, Error<GetVarziaByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/vaultTrader", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VoidTrader`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VoidTrader`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVarziaByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Information on the current Void Traders offerings, or when they will arrive.
pub async fn get_void_traders_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<Vec<models::VoidTrader>, Error<GetVoidTradersByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc/voidTraders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::VoidTrader&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::VoidTrader&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVoidTradersByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The full translated Warframe Worldstate
pub async fn get_worldstate_by_platform(configuration: &configuration::Configuration, language: models::Language, accept_language: Option<models::Language>) -> Result<models::Ws, Error<GetWorldstateByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_language = language;
    let p_header_accept_language = accept_language;

    let uri_str = format!("{}/pc", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("language", &p_query_language.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Ws`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Ws`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorldstateByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Data about averages, deviations, medians, miniums, and maxes for rivens whose name match the query for the provided platform
pub async fn search_rivens_by_platform(configuration: &configuration::Configuration, query: &str) -> Result<std::collections::HashMap<String, models::Riven>, Error<SearchRivensByPlatformError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_query = query;

    let uri_str = format!("{}/pc/rivens/search/{query}", configuration.base_path, query=crate::apis::urlencode(p_path_query));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::Riven&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::Riven&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchRivensByPlatformError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

